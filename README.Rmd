---
title: "MicrogliaMorphologyR"
output: github_document
always_allow_html: true
---

```{r setup, include=FALSE}
```

**Created**: 26 June, 2023 by Jenn Kim  
**Last updated**: `r format(Sys.time(), '%d %B, %Y')`

## Welcome to MicrogliaMorphologyR!
MicrogliaMorphologyR is an R package for microglia morphology analysis, that is complimentary to ImageJ macro [MicrogliaMorphology](https://github.com/ciernialab/MicrogliaMorphology). Using MicrogliaMorphologyR, you can perform exploratory data analysis and visualization of 27 different morphology features and perform dimensionality reduction, clustering, and statistical analysis of your data. 

#### If you are using this tool, please cite the following publications:
- Insert manuscript link

## Instructions on how to use MicrogliaMorphologyR

### install and load package
```{r, eval=FALSE}
BiocManager::install('ciernialab/MicrogliaMorphologyR')
```

```{r}
devtools::load_all()
library(MicrogliaMorphologyR)
```

We will start by loading in your MicrogliaMorphology output (FracLac and SkeletonAnalysis files) and formatting the data so that you have a final dataframe which contains your cell-level data, with every row as a single cell and every column as either a metadata descriptor or morphology measure.

### load in your fraclac and skeleton data, tidy, and merge into final data frame
```{r, eval=FALSE}
fraclac.dir <- "insert path to fraclac directory"
skeleton.dir <- "insert path to skeleton analysis directory"

fraclac <- fraclac_tidying(fraclac.dir)
skeleton <- skeleton_tidying(skeleton.dir)

data <- merge_data(fraclac, skeleton)
finaldata <- metadata_columns(data,
                              c("Antibody","Paper","Cohort","MouseID","Sex","Treatment","BrainRegion","Subregion"),
                              sep="_")
```

For demonstration purposes, we will use one of the datasets that comes packaged with MicrogliaMorphologyR. 'data_2xLPS_mouse' contains morphology data collected from female and male 8 week-old Cx3cr1-eGFP mice, which were given 2 i.p. injections of either PBS vehicle solution or 0.5mg/kg lipopolysaccharides (LPS), spaced 24 hours apart. In this genetic mouse line, Cx3cr1-expressing cells including microglia have an endogenous reporter which makes them yellow when immunofluorescently imaged. Brains were collected 24 hours after the final injections, and brain sections were immunofluorescently stained and imaged for 2 additional, commonly used microglia markers: P2ry12, and Iba1.

### load in example dataset
```{r}
data_2xLPS <- MicrogliaMorphologyR::data_2xLPS_mouse
```

MicrogliaMorphologyR comes with a number of functions which allow you to explore which features have extreme outliers and how normalizing in various ways changes your feature distributions. This allows you to explore and transform your data in a dataset-appropriate manner for downstream analyses. You can also generate a heatmap of correlations across the 27 different morphology features to investigate how they relate to each other. You can use this function to verify that features which explain similar aspects of cell morphology are more related to each other (e.g, features which describe cell area/territory span should all be highly correlated to each other compared to other features which do not).

### exploratory data visualization and data transformation for downstream analyses
```{r}
# gather your numerical morphology data into one column ('measure') which contains the feature name, and another column ('value') which contains measured values
data_2xLPS_gathered <- data_2xLPS %>% gather(measure, value, 9:ncol(data_2xLPS))

# check for outliers
outliers_boxplots(data_2xLPS_gathered)
outliers_distributions(data_2xLPS_gathered)

# checking different normalization features
normalize_logplots(data_2xLPS_gathered,1)
normalize_minmax(data_2xLPS_gathered)
normalize_scaled(data_2xLPS_gathered)

# transform your data in appropriate manner for downstream analyses
data_2xLPS_logtransformed <- transform_log(data_2xLPS, 1, start=9, end=35) # we will use the logtransformed data as our PCA input
data_2xLPS_minmaxtransformed <- transform_minmax(data_2xLPS, start=9, end=35)
data_2xLPS_scaled <- transform_scale(data_2xLPS, start=9, end=35)

# get sample size of data based on factors of interest
samplesize(data_2xLPS, MouseID, Antibody)
samplesize(data_2xLPS, Sex, Treatment, Antibody)
```

### generate heatmap of correlations across features
```{r, fig.width=13, fig.height=12.5}
featurecorrelations(data_2xLPS, start=9, end=35, rthresh=0.8, pthresh=0.05, title="Correlations across features")
```

Now, since we have gotten a better feel for our data and how to transform it if needed, we can proceed with PCA for dimensionality reduction and downstream clustering. We can see here that the first 4 PCs describe around ~90% of our data. We can also explore how each PC correlates to the 27 different morphology features to get a better understanding of how each PC describes the variability captured by the data. This is useful to inform which to include for downstream clustering steps. 

## Dimensionality reduction using PCA
```{r}
set.seed(1)
pcadata_elbow(data_2xLPS_logtransformed, start=9, end=35)
pca_data <- pcadata(data_2xLPS_logtransformed, start=9, end=35,
                    pc.start=1, pc.end=10)
str(pca_data)
```

### generate heatmap of correlations between PCs and features
```{r, fig.width=10, fig.height=8}
pcfeaturecorrelations(pca_data, pc.start=1, pc.end=3, 
                      feature.start=19, feature.end=45, 
                      rthresh=0.75, pthresh=0.05, 
                      title="Correlation between PCs and features")
```

### visually explore different sources of variability in dataset
```{r, fig.width=13, fig.height=12.5}
# gather your data by experimental variables (e.g., Treatment, Sex, MouseID, etc.)
gathered_expvariables <- pca_data %>% gather(variable, value, 11:16) 

plots_expvariable(gathered_expvariables, "PC1", "PC2")
```

## Soft clustering using Fuzzy K-means 

After performing dimensionality reduction, we can use our PCs as input for downstream clustering methods. Here, we use fuzzy k-means, a 'soft' clustering method that is similar in concept and algorithm to k-means clustering, which partitions data points within a given dataset into defined numbers of clusters based on their proximity to the nearest clusterâ€™s centroid. In fuzzy k-means, data points are not exclusively assigned to just one cluster, but rather given membership scores to all clusters. This allows for additional characterization of high-scoring cells within each cluster (i.e., quintessential 'rod-like', 'ameboid', 'hypertrophic', or 'ramified' cells), cells with more ambiguous identities (e.g., a cell that is 5% rod-like, 5% ameboid, 45% hypertrophic, and 45% ramified), and other cases that the user might be interested in which might be informative for their specific dataset. Fuzzy k-means also assigns a final hard cluster assignment based on the class with the highest membership score, so you can also use these final assignments as your input for downstream analysis. 

### prepare data for clustering
```{r}
## for k-means clustering: scale PCs 1-3, which together describe ~85% of variability
pca_data_scale <- transform_scale(pca_data, start=1, end=3) # scale pca data as input for k-means clustering
kmeans_input <- pca_data_scale[1:3]
```

### Cluster optimization prior to running fuzzy k-means
```{r}
# check for optimal number of clusters using wss and silhouette methods
set.seed(2)
sampling <- kmeans_input[sample(nrow(kmeans_input), 5000),] #sample 5000 random rows for cluster optimization

fviz_nbclust(sampling, kmeans, method = 'wss', nstart=25, iter.max=50) # 4 clusters
fviz_nbclust(sampling, kmeans, method = 'silhouette', nstart=25, iter.max=50) # 4 clusters
```

From using the wss and silhouette methods to check the optimal numbers of clusters for our dataset, it appears that our data would be optimally clustered using k=4. There are many more cluster optimization methods that you can try out to explore your data (insert link). 

Next, we proceed with clustering. You can cluster using fuzzy k-means or regular k-means at this step. After clustering, we will use some built-in functions within MicrogliaMorphologyR to assess how a parameter of k=4 influences how the clusters are defined by morphology features (and if they make sense according to what we know about microglia morphology). As this step may require some troubleshooting and updating of clustering parameters, you may need to run your k-means function multiple times. Fuzzy k-means is more time-intensive and computationally expensive so it might help to use regular k-means as a first pass, verify that your clusters make sense using the functions that follow, and run your fuzzy k-means function using the final parameters that you determine to generate your final dataset for downstream analysis.

## Clustering

### Fuzzy k-means (soft clustering)
```{r, eval=FALSE}
# cluster and combine with original data
library(ppclust)
set.seed(3)
data_kmeans <- fcm(kmeans_input, centers=4, nstart=25)
pca_kmeans <- cbind(pca_data[1:5], data_kmeans)
str(pca_kmeans)
```

### Regular k-means (hard clustering)
```{r}
# cluster and combine with original data
data_kmeans <- kmeans(kmeans_input, centers=4)
pca_kmeans <- cbind(pca_data[1:2], data_2xLPS, as.data.frame(data_kmeans$cluster)) %>%
  rename(Cluster=`data_kmeans$cluster`)
str(pca_kmeans)
```

### Plot k-means clusters in PC space
```{r}
plot <- clusterplots(pca_kmeans, "PC1", "PC2")
plot
plot + scale_colour_viridis_d() # customizeable example: add color scheme of choice 
```

### Cluster-specific measures on average for each morphology feature, relative to other clusters
```{r}
clusterfeatures(pca_kmeans, start=11, end=37)
```

### Cluster characterization
```{r, fig.width=13, fig.height=12.5}
# calculate cluster percentages across variables of interest
cp <- clusterpercentage(pca_kmeans, "Cluster", MouseID, Antibody, Treatment, Sex, BrainRegion)
cp$Treatment <- factor(cp$Treatment, levels=c("PBS","2xLPS"))

# Quick check of cluster proportions when considering experimental variables of interest
cp %>% 
  filter(BrainRegion=="STR") %>% # in this example, we filter for our brain region of interest
  clusterpercentage_boxplots(Antibody, Treatment) # grouping variables
```

```{r, fig.width=13, fig.height=5}
# example graph of data given variables of interest
cp %>% 
  filter(Antibody=="Iba1") %>%
  ggplot(aes(x=Cluster, y=percentage, group=interaction(Cluster, Treatment))) +
  facet_wrap(~BrainRegion) +
  geom_boxplot(aes(group=interaction(Cluster, Treatment), fill=Treatment)) +
  scale_fill_manual(values=c("#fde725","#482878")) +
  geom_point(position=position_dodge(width=0.8), size=0.75, aes(group=interaction(Cluster,Treatment), color=Sex)) +
  ggtitle("2xLPS mouse dataset: K-means clusters") +
  labs(fill="Treatment") +
  theme_bw(base_size=14) +
  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1))
```

## Statistical analysis

MicrogliaMorphologyR includes a few functions to run stats on cluster percentages as well as on individual morphology measures. 

### Cluster percentage changes at animal level, in response to experimental variables
#### e.g., Across clusters - How does cluster membership change with LPS?

The stats_cluster.animal function fits a generalized linear mixed model on your dataset to a beta distribution, which is suitable for values like percentages or probabilities that are constrained to a range of 0-1, using the `glmmTMB` package. Part of the output includes a check of the model fit using the `DHARMa` package, which "uses a simulation-based approach to create readily interpretable scaled (quantile) residuals for fitted (generalized) linear mixed models." The function creates two `DHARMa` plots, contained in output[[4]]. You can read more about how to interpret model fit using `DHARMa` by reading the package [vignette](https://cran.r-project.org/web/packages/DHARMa/vignettes/DHARMa.html). 

```{r}
# prepare percentages dataset for downstream analysis
stats.input <- cp %>% filter(BrainRegion=="FC", Antibody=="Iba1")
stats.input$MouseID <- factor(stats.input$MouseID)
stats.input$Cluster <- factor(stats.input$Cluster)
stats.input$Treatment <- factor(stats.input$Treatment)

# run stats analysis for changes in cluster percentages, at the animal level
# you can specify up to two posthoc comparisons (posthoc1 and posthoc2 arguments) - if you only have one set of posthocs to run, specify the same comparison twice for both arguments. you will just get the same results in output[[2]] and output[[3]].
stats.testing <- stats_cluster.animal(stats.input, "percentage ~ Cluster*Treatment + (1|MouseID)", 
                                      "~Cluster*Treatment", "~Treatment|Cluster", "bonferroni")

stats.testing[[1]] # anova
stats.testing[[2]] # posthoc 1
stats.testing[[3]] # posthoc 2
stats.testing[[4]] # DHARMa model check
stats.testing[[5]] # summary of model
```

### Individual morphology measures, at the animal level (averaged for each measure)
#### e.g., How does each individual morphology measure change with LPS treatment?

The stats_morphologymeasures.animal function fits a linear model using the `lm` function for each morphology measure individually within your dataset.
```{r, fig.width=13, fig.height=12.5}
# prepare data for downstream analysis
data <- data_2xLPS %>% 
  group_by(MouseID, Sex, Treatment, BrainRegion, Antibody) %>% 
  summarise(across("Foreground pixels":"Maximum branch length", ~mean(.x))) %>% 
  gather(Measure, Value, "Foreground pixels":"Maximum branch length")

# filter out data you want to run stats on and make sure to make any variables included in model into factors
stats.input <- data %>% filter(BrainRegion=="FC", Antibody=="Iba1") 
stats.input$Treatment <- factor(stats.input$Treatment)

# run stats analysis for changes in individual morphology measures
# you can specify up to two posthoc comparisons (posthoc1 and posthoc2 arguments) - if you only have one set of posthocs to run, specify the same comparison twice for both arguments. you will just get the same results in output[[2]] and output[[3]].
stats.testing <- stats_morphologymeasures.animal(stats.input, "Value ~ Treatment", 
                                                 "~Treatment", "~Treatment", "bonferroni")

stats.testing[[1]] # anova
stats.testing[[2]] # posthoc 1
stats.testing[[3]] # posthoc 2
do.call("grid.arrange", c(stats.testing[[4]], ncol=4)) # qqplots to check normality assumptions
stats.testing[[5]] # summary of model
```
### Individual morphology measures, at the cell level
#### e.g., How does each individual morphology measure change with LPS treatment?

The stats_morphologymeasures.cell function fits a linear mixed effects model considering MouseID as a repeated measure using the `lmerTest` package, for each morphology measure individually within your dataset. The `lmerTest` package "provides p-values in type I, II or III anova and summary tables for linear mixed models...via Satterthwaite's degrees of freedom method." You can learn more about the package by reading the `lmerTest` [reference manual](https://cran.r-project.org/web/packages/lmerTest/lmerTest.pdf)

```{r, fig.width=13, fig.height=12.5}
# prepare data for downstream analysis
data <- data_2xLPS_logtransformed %>% 
  group_by(MouseID, Sex, Treatment) %>% 
  gather(Measure, Value, "Foreground pixels":"Maximum branch length")

# filter out data you want to run stats on and make sure to make any variables included in model into factors
stats.input <- data %>% filter(BrainRegion=="FC", Antibody=="Iba1") 
stats.input$Treatment <- factor(stats.input$Treatment)
stats.input$MouseID <- factor(stats.input$MouseID)

# run stats analysis for changes in individual morphology measures
# you can specify up to two posthoc comparisons (posthoc1 and posthoc2 arguments) - if you only have one set of posthocs to run, specify the same comparison twice for both arguments. you will just get the same results in output[[2]] and output[[3]].
stats <- stats_morphologymeasures.cell(stats.input, "Value ~ Treatment + (1|MouseID)", 
                                  "~Treatment", "~Treatment", "bonferroni")

stats[[1]] # anova
stats[[2]] # posthoc 1
stats[[3]] # posthoc 2
do.call("grid.arrange", c(stats[[4]], ncol=4)) # qqplots to check normality assumptions
stats[[5]] # summary of model
```
If you find that any individual morphology measures violate assumptions of normality after checking the qqplots contained in stats.input[[4]], you can filter your data for those measures, transform your data in the suitable manner (i.e., using MicrogliaMorphologyR functions like `transform_minmax` or `transform_scale` or other data transformations), and rerun the stats for those morphology features using the code above.

### testing
```{r, eval=FALSE}
data <- MicrogliaMorphologyR::data_2xLPS_fuzzykmeans
hist(data_2xLPS_fuzzykmeans$`Cluster 3`)

data <- data_2xLPS_fuzzykmeans %>% 
  filter(`Cluster 1` > 0.70|
         `Cluster 2` > 0.70|
         `Cluster 3` > 0.70|
         `Cluster 4` > 0.70)
```
